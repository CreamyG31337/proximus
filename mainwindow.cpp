// checksum 0xa193 version 0x30001
/*
  This file was generated by the Mobile Qt Application wizard of Qt Creator.
  MainWindow is a convenience class containing mobile device specific code
  such as screen orientation handling.
  It is recommended not to modify this file, since newer versions of Qt Creator
  may offer an updated version of it.
*/

#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "rule1.h"
#include <QDebug>


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow)
//    , subscriber(new QValueSpaceSubscriber("/net/appcheck/Proximus"))
//    , publisher(new QValueSpacePublisher(QValueSpace::WritableLayer,"/net/appcheck/Proximus"))
    , settings(new QSettings("FakeCompany","Proximus") )
{
    QCoreApplication::setOrganizationName("FakeCompany");
    QCoreApplication::setOrganizationDomain("appcheck.net");
    QCoreApplication::setApplicationName("Proximus");
    ui->setupUi(this);

    //ptr to dialog
    Ruledialog = 0;    
    //fill current rules list,settings from "/net/appcheck/Proximus/";


    if (!settings->contains("settings")) //first run, need to create default settings
    {
        settings->setValue("settings/GPS",false);

    }

//    if (!subscriber->value().isValid()) //need to create /net/appcheck/Proximus/
//    {
//        if (publisher->isConnected())
//        {   //set default options
//            publisher->setValue("settings/GPS",false);
//        }
//        else
//        {
//            //critical error - unable to write to gconf
//            QMessageBox::critical(this,"error","error writing data with publisher ");
//            qApp->exit(1);
//        }
//    }

//    ui->chkGPSMode->setChecked(subscriber->value("settings/GPS").Bool);
    ui->chkGPSMode->setChecked(settings->value("settings/GPS").Bool);

    if (!settings->contains("rules")) //first run, need to create default rules
    {
        settings->beginGroup("rules");
        settings->setValue("Example Rule/deleted",(bool)false);//for some reason setting the value of a node that contains subkeys doesn't work properly
        settings->setValue("Example Rule/enabled",(bool)false);//so i have to program it this stupid way instead.
        settings->setValue("Example Rule/Location/enabled",(bool)true);
        settings->setValue("Example Rule/Location/NOT",(bool)false);
        settings->setValue("Example Rule/Location/RADIUS",(double)250);
        settings->setValue("Example Rule/Location/LONGITUDE",(double)-113.485336);
        settings->setValue("Example Rule/Location/LATITUDE",(double)53.533064);
        settings->endGroup();
    }

//    subscriber->cd("rules");
//    if (!subscriber->value().isValid()) //need to create /net/appcheck/Proximus/rules
//    {
//        //set default rule, disable it
//        publisher->setValue("rules/Example Rule/deleted",(bool)false);//for some reason setting the value of a node that contains subkeys doesn't work properly
//        publisher->setValue("rules/Example Rule/enabled",(bool)false);//so i have to program it this stupid way instead.
//        publisher->setValue("rules/Example Rule/Location/enabled",(bool)true);
//        publisher->setValue("rules/Example Rule/Location/NOT",(bool)false);
//        publisher->setValue("rules/Example Rule/Location/RADIUS",(double)250);
//        publisher->setValue("rules/Example Rule/Location/LONGITUDE",(double)-113.485336);
//        publisher->setValue("rules/Example Rule/Location/LATITUDE",(double)53.533064);
//        publisher->sync();
//    }
    //update rules list if anything changes


    //QObject::connect(subscriber, SIGNAL(contentsChanged()), this, SLOT(rulesStorageChanged()));

    rulesStorageChanged();//call once now to populate initial rules
    // Start the GPS
    startGPS();
}

MainWindow::~MainWindow()
{
    settings->sync();
    delete ui;
    delete Ruledialog;
//    delete subscriber;
//    delete publisher;
    delete settings;
}

void MainWindow::setOrientation(ScreenOrientation orientation)
{
#if defined(Q_OS_SYMBIAN)
    // If the version of Qt on the device is < 4.7.2, that attribute won't work
    if (orientation != ScreenOrientationAuto) {
        const QStringList v = QString::fromAscii(qVersion()).split(QLatin1Char('.'));
        if (v.count() == 3 && (v.at(0).toInt() << 16 | v.at(1).toInt() << 8 | v.at(2).toInt()) < 0x040702) {
            qWarning("Screen orientation locking only supported with Qt 4.7.2 and above");
            return;
        }
    }
#endif // Q_OS_SYMBIAN

    Qt::WidgetAttribute attribute;
    switch (orientation) {
#if QT_VERSION < 0x040702
    // Qt < 4.7.2 does not yet have the Qt::WA_*Orientation attributes
    case ScreenOrientationLockPortrait:
        attribute = static_cast<Qt::WidgetAttribute>(128);
        break;
    case ScreenOrientationLockLandscape:
        attribute = static_cast<Qt::WidgetAttribute>(129);
        break;
    default:
    case ScreenOrientationAuto:
        attribute = static_cast<Qt::WidgetAttribute>(130);
        break;
#else // QT_VERSION < 0x040702
    case ScreenOrientationLockPortrait:
        attribute = Qt::WA_LockPortraitOrientation;
        break;
    case ScreenOrientationLockLandscape:
        attribute = Qt::WA_LockLandscapeOrientation;
        break;
    default:
    case ScreenOrientationAuto:
        attribute = Qt::WA_AutoOrientation;
        break;
#endif // QT_VERSION < 0x040702
    };
    setAttribute(attribute, true);
}

void MainWindow::showExpanded()
{
#ifdef Q_OS_SYMBIAN
    showFullScreen();
#elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
    showMaximized();
#else
    show();
#endif
}

void MainWindow::rulesStorageChanged() {

    //setup memory structure used to keep track of rules being active or not
    //also recreate qstringlist obj on screen
    //as this DOES NOT happen often, it's okay to recreate from scratch
    Rules.clear();
    ui->listWidgetRules->clear();

    //fill list
    settings->beginGroup("rules");
    //Q_FOREACH(const QString &strRuleName, subscriber->subPaths()){//for each rule
    Q_FOREACH(const QString &strRuleName, settings->childGroups()){//for each rule
        //TODO: file bug and replace this retarded line of code with a simple "isValid" check. not holding my breath.
        //if (!subscriber->value(strRuleName + "/deleted",true).toBool() == true)//if 'not deleted' (reset values is NOT working as it should, buggy??)
        //{
            ui->listWidgetRules->addItem(strRuleName);//add name to screen list

//            if (subscriber->value(strRuleName + "/enabled").toBool() == true){//if enabled
              if (settings->value(strRuleName + "/enabled").toBool() == true){//if enabled
                Rule* newRule = new Rule();
                newRule->name = strRuleName;
                Rules.insert(strRuleName,newRule);
                ui->listWidgetRules->item(ui->listWidgetRules->count() - 1)->setForeground(Qt::green);
                newRule->enabled = true;
                //ui->listWidgetRules->findItems(str,Qt::MatchExactly).first()->setForeground(Qt::green);
                DataLocation* ptrRuleDataLoc = new DataLocation;
                ptrRuleDataLoc->setParent(newRule);
                newRule->data.locationRule = ptrRuleDataLoc;
                connect(newRule->data.locationRule, SIGNAL(activeChanged(Rule*)),
                        this,SLOT(checkStatus(Rule*)));

                //fill them -- TODO: need to check if the paths exist, default them
                ptrRuleDataLoc->active = false;//we can default the status to false, it will be re-evaluated within a minute
//                ptrRuleDataLoc->enabled = subscriber->value(strRuleName + "/Location/enabled").toBool();
//                ptrRuleDataLoc->inverseCond = subscriber->value(strRuleName + "/Location/NOT").toBool();
//                ptrRuleDataLoc->radius = subscriber->value(strRuleName + "/Location/RADIUS").toInt();
//                ptrRuleDataLoc->location.setLongitude(subscriber->value(strRuleName + "/Location/LONGITUDE").toDouble());
//                ptrRuleDataLoc->location.setLatitude(subscriber->value(strRuleName + "/Location/LATITUDE").toDouble());
                ptrRuleDataLoc->enabled = settings->value(strRuleName + "/Location/enabled").toBool();
                ptrRuleDataLoc->inverseCond = settings->value(strRuleName + "/Location/NOT").toBool();
                ptrRuleDataLoc->radius = settings->value(strRuleName + "/Location/RADIUS").toInt();
                ptrRuleDataLoc->location.setLongitude(settings->value(strRuleName + "/Location/LONGITUDE").toDouble());
                ptrRuleDataLoc->location.setLatitude(settings->value(strRuleName + "/Location/LATITUDE").toDouble());
                if (ptrRuleDataLoc->enabled)
                {
                    ptrRuleDataLoc->areaMon = initAreaMonitor(ptrRuleDataLoc);
                }

                newRule->data.timeRule.active = false;
//                newRule->data.timeRule.enabled = subscriber->value(strRuleName + "/Time/enabled").toBool();
//                newRule->data.timeRule.inverseCond = subscriber->value(strRuleName + "/Time/NOT").toBool();
//                newRule->data.timeRule.time1 = subscriber->value(strRuleName + "/Time/TIME1").toTime();
//                newRule->data.timeRule.time2 = subscriber->value(strRuleName + "/Time/TIME2").toTime();
                newRule->data.timeRule.enabled = settings->value(strRuleName + "/Time/enabled").toBool();
                newRule->data.timeRule.inverseCond = settings->value(strRuleName + "/Time/NOT").toBool();
                newRule->data.timeRule.time1 = settings->value(strRuleName + "/Time/TIME1").toTime();
                newRule->data.timeRule.time2 = settings->value(strRuleName + "/Time/TIME2").toTime();

                newRule->data.calendarRule.active = false;
//                newRule->data.calendarRule.enabled = subscriber->value(strRuleName + "/Calendar/enabled").toBool();
//                newRule->data.calendarRule.inverseCond = subscriber->value(strRuleName + "/Calendar/NOT").toBool();
//                newRule->data.calendarRule.keywords = subscriber->value(strRuleName + "/Calendar/KEYWORDS").toString();
                newRule->data.calendarRule.enabled = settings->value(strRuleName + "/Calendar/enabled").toBool();
                newRule->data.calendarRule.inverseCond = settings->value(strRuleName + "/Calendar/NOT").toBool();
                newRule->data.calendarRule.keywords = settings->value(strRuleName + "/Calendar/KEYWORDS").toString();
            }
            else{//rule was not enabled, we skipped all of the above
                ui->listWidgetRules->item(ui->listWidgetRules->count() - 1)->setForeground(Qt::red);
                //newRule->enabled = false;
                //ui->listWidgetRules->findItems(str,Qt::MatchExactly).first()->setForeground(Qt::red);
                //return?
            }
       // }
    }
    settings->endGroup();
}

//triggered by a heartbeat timer object every 45 min or so,
//checks calendar for any keyword matches and sets more timers to change the rule to active when those become current.
//if this api made any sense, i could use signals too
void MainWindow::updateCalendar()
{
    QOrganizerManager defaultManager; //provides access to system address book, calendar
    //get list of all upcoming calendar events
    QList<QOrganizerItem> entries =
             defaultManager.items(QDateTime::currentDateTime(),//not sure if this returns events already started
                                  QDateTime::currentDateTime().addSecs(3600)); //read next hour of calendar data
    //for each calendar rule
    Q_FOREACH(Rule* ruleStruct,  Rules) {
        bool foundMatch = false;
        QString keywords = ruleStruct->data.calendarRule.keywords;
        //seperate keywords string into list of keywords
        QStringList keywordList = keywords.split(" ");
        //then loop through all the upcoming calendar events
        Q_FOREACH(QOrganizerItem orgItem, entries){
            //and each individual keyword
            Q_FOREACH(QString keyword, keywordList){
                if (orgItem.description().contains(keyword)) {
                    //keyword match, set up timer to activate this rule
                    foundMatch = true;
                    QTimer *activateTimer = new QTimer(this);
                    QTimer *deactivateTimer = new QTimer(this);
                    connect(activateTimer, SIGNAL(timeout()), this, SLOT(activateCalendarRule(ruleStruct)));
                    connect(deactivateTimer, SIGNAL(timeout()), this, SLOT(deactivateCalendarRule(ruleStruct)));
                    //find seconds until event
                    qint16 startTimeDiff, endTimeDiff;
                    QOrganizerEventTime eventTime = orgItem.detail<QOrganizerEventTime>();
                    startTimeDiff = QDateTime::currentDateTime().secsTo(eventTime.startDateTime());
                    endTimeDiff = QDateTime::currentDateTime().secsTo(eventTime.endDateTime());
                    activateTimer->start(startTimeDiff * 1000);//timer is in ms
                    deactivateTimer->start(endTimeDiff * 1000);//these could be negative if all day event?
                }
                //if keywords not found but rule is inversed, we still need to set to active (now)
                if (foundMatch == false && ruleStruct->data.calendarRule.inverseCond == true)
                {
                     ruleStruct->data.calendarRule.active = true;
                }
            }
        }
    }
}

//sets rule to active
void MainWindow::activateCalendarRule(Rule* ruleStruct)
{
    if (ruleStruct->data.calendarRule.inverseCond == false)
        ruleStruct->data.calendarRule.active = true;
    else
        ruleStruct->data.calendarRule.active = false;
}

//sets rule to inactive
void MainWindow::deactivateCalendarRule(Rule* ruleStruct)
{
    if (ruleStruct->data.calendarRule.inverseCond == false)
        ruleStruct->data.calendarRule.active = false;
    else
        ruleStruct->data.calendarRule.active = true;
}

void MainWindow::positionUpdated(QGeoPositionInfo geoPositionInfo)
{
    if (geoPositionInfo.isValid())
    {
        //gps never stops
        //locationDataSource->setUpdateInterval(30*1000);//30 sec //TODO: for meego we should sync this to WAKEUP_SLOT_30_SEC in MeeGo::QmHeartbeat
        // Get the current location as latitude and longitude
        QGeoCoordinate geoCoordinate = geoPositionInfo.coordinate();
        qreal latitude = geoCoordinate.latitude();
        qreal longitude = geoCoordinate.longitude();
        ui->lblLongitude->setText(QString::number(longitude));
        ui->lblLatitude->setText(QString::number(latitude));
        ui->lblLastUpdatedTime->setText(geoPositionInfo.timestamp().toString());
        ui->lblAccuracy->setText(QString::number(geoPositionInfo.attribute(QGeoPositionInfo::HorizontalAccuracy)) + "m");
        //qDebug() << Rules["Example Rule"]->data.timeRule.time1;
    }
}

void MainWindow::startGPS()
{
    // Obtain the location data source if it is not obtained already
    if (!locationDataSource){
        locationDataSource = QGeoPositionInfoSource::createDefaultSource(this);
        if (!locationDataSource){
            // Not able to obtain the location data source
            // TODO: Error handling
            QMessageBox::critical(this,"error","GPS failure");
            return;
        }
    }
    // Whenever the location data source signals that the current
    // position is updated, the positionUpdated function is called.
    QObject::connect(locationDataSource,
                     SIGNAL(positionUpdated(QGeoPositionInfo)),
                     this,
                     SLOT(positionUpdated(QGeoPositionInfo)));

    if (ui->chkGPSMode->isChecked())
        locationDataSource->setPreferredPositioningMethods(QGeoPositionInfoSource::NonSatellitePositioningMethods);    
    else
        locationDataSource->setPreferredPositioningMethods(QGeoPositionInfoSource::AllPositioningMethods);
    // Start listening for position updates
    locationDataSource->startUpdates();

    //set up timer for calendar,
    #if defined(Q_WS_MAEMO_5)
        //worry about this later
    #else
        #if defined (Q_WS_SIMULATOR)
            //
        #else //harmattan or symbian...
            QSystemAlignedTimer *newTimer = new QSystemAlignedTimer(this);
            connect (newTimer, SIGNAL(timeout()),this,SLOT(updateCalendar()));
            newTimer->start(60*45,60*60); //timer should fire every 45-60 min
        #endif
    #endif
}

//called any time we activate / deactivate a rule setting
//this just does some boolean math to check if the whole rule is now active or inactive
void MainWindow::checkStatus(Rule* ruleStruct)
{

}

//create and return a (pointer to) a single QGeoAreaMonitor
QGeoAreaMonitor * MainWindow::initAreaMonitor(DataLocation *& Dataloc)
{
    // Create the area monitor
    QGeoAreaMonitor *monitor = QGeoAreaMonitor::createDefaultMonitor(Dataloc);
    if (monitor == NULL){
         QMessageBox::critical(this,"error","failed to create monitor");
         return NULL;
    }

    // Connect the area monitoring signals to the corresponding slots
    if (!connect(monitor, SIGNAL(areaEntered(QGeoPositionInfo)),
             Dataloc, SLOT(areaEntered(QGeoPositionInfo))))
        QMessageBox::critical(this,"error","error connecting slots");

    connect(monitor, SIGNAL(areaExited(QGeoPositionInfo)),
            Dataloc, SLOT(areaExited(QGeoPositionInfo)));
    monitor->setCenter(Dataloc->location);
    monitor->setRadius(Dataloc->radius);
    return monitor;
}

void DataLocation::areaEntered(const QGeoPositionInfo &update) {
    // The area has been entered
    QMessageBox::information(NULL,"debug","entered area",QMessageBox::Ok);
    if (this->inverseCond == false)
        this->active = true;
    else
        this->active = false;
    Q_EMIT activeChanged((Rule*)this->parent());
}

void DataLocation::areaExited(const QGeoPositionInfo &update) {
    // The area has been exited
     QMessageBox::information(NULL,"debug","exited area",QMessageBox::Ok);
     if (this->inverseCond == false)
         this->active = false;
     else
         this->active = true;
     Q_EMIT activeChanged((Rule*)this->parent());
}

Rule::Rule()
{

}

RuleData::RuleData()
    :locationRule(new DataLocation)
{
//init ptr to datalocation obj

}

DataLocation::DataLocation()
    //:areaMon(new QGeoAreaMonitor::createDefaultMonitor())
{

}


void MainWindow::startSatelliteMonitor()
{
    satelliteInfoSource =
        QGeoSatelliteInfoSource::createDefaultSource(this);
    // Whenever the satellite info source signals that the number of
    // satellites in use is updated, the satellitesInUseUpdated function
    // is called
    QObject::connect(satelliteInfoSource,
                     SIGNAL(satellitesInUseUpdated(
                             const QList<QGeoSatelliteInfo>&)),
                     this,
                     SLOT(satellitesInUseUpdated(
                             const QList<QGeoSatelliteInfo>&)));

    // Whenever the satellite info source signals that the number of
    // satellites in view is updated, the satellitesInViewUpdated function
    // is called
    QObject::connect(satelliteInfoSource,
                     SIGNAL(satellitesInViewUpdated(
                             const QList<QGeoSatelliteInfo>&)),
                     this,
                     SLOT(satellitesInViewUpdated(
                             const QList<QGeoSatelliteInfo>&)));

    // Start listening for satellite updates
    satelliteInfoSource->startUpdates();
}

void MainWindow::satellitesInUseUpdated(
        const QList<QGeoSatelliteInfo> &satellites) {
    // The number of satellites in use is updated
    QMessageBox msgBox;
    msgBox.setText("The number of satellites in use is updated: " +
                   QString::number(satellites.count()));
    msgBox.exec();
}

void MainWindow::satellitesInViewUpdated(
        const QList<QGeoSatelliteInfo> &satellites) {
    // The number of satellites in view is updated
    QMessageBox msgBox;
    msgBox.setText("The number of satellites in view is updated: " +
                   QString::number(satellites.count()));
    msgBox.exec();
}

void MainWindow::on_btnNewRule_clicked()
{

    qint8 intRuleToEdit =  ui->listWidgetRules->count() + 1;
    if (Ruledialog == 0)
    {
        Ruledialog =  new Rule1(topLevelWidget(),"Rule " +  QString::number(intRuleToEdit),locationDataSource);
    }
    #ifdef Q_OS_SYMBIAN
         Ruledialog->showFullScreen();//modeless to keep GPS running
    #elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
         Ruledialog->showMaximized();//modeless to keep GPS running
    #else
         Ruledialog->show();//modeless to keep GPS running
    #endif
}

void MainWindow::on_chkGPSMode_clicked()
{

    settings->setValue("settings/GPS",ui->chkGPSMode->isChecked());
//    if (publisher->isConnected())
//    {
//        publisher->setValue("settings/GPS",ui->chkGPSMode->isChecked());
//    }
//    else
//    {
//        QMessageBox::critical(this,"error","failed to write settings");
//    }
    startGPS();//(restart)
}

void MainWindow::on_btnEdit_clicked()
{
    if (!ui->listWidgetRules->currentItem()) return;//no item selected; could show messagebox, if even possible to end up in this situation
    if (Ruledialog == 0)
    {
        Ruledialog =  new Rule1(window(), ui->listWidgetRules->currentItem()->text(),locationDataSource);
    }
    #ifdef Q_OS_SYMBIAN
         Ruledialog->showFullScreen();//modeless to keep GPS running
    #elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
         Ruledialog->showMaximized();//modeless to keep GPS running
    #else
         Ruledialog->show();//modeless to keep GPS running
    #endif
}

void MainWindow::on_btnDelete_clicked()
{
    if (!ui->listWidgetRules->currentItem()) return;//no item selected; could show messagebox, if even possible to end up in this situation
    int ret = (QMessageBox::question(this,
                             "Please confirm",
                             "Do you wish to delete rule: '"+ ui->listWidgetRules->currentItem()->text()+"'",
                             QMessageBox::Yes | QMessageBox::No,
                             QMessageBox::No)
              );
    if (ret == QMessageBox::Yes){
        //hi, i'm nokia and i can't make a resetValue function that works properly. this will NOT delete the root node for some stupid reason. more hours of my life gone.
//        publisher->resetValue("rules/" + ui->listWidgetRules->currentItem()->text());//yeah so it doesn't seem to be doing ANYTHING right now.
//        publisher->setValue("rules/" + ui->listWidgetRules->currentItem()->text() + "/deleted",true);//i guess i will write stupid code then.
        settings->remove("rules/" + ui->listWidgetRules->currentItem()->text());
    }
    settings->sync();
//    publisher->sync();
}

void MainWindow::on_listWidgetRules_currentTextChanged(const QString &currentText)
{
    if (currentText.isNull())//nothing selected
    {
        ui->btnDelete->setEnabled(false);
        ui->btnEnable->setEnabled(false);
        ui->btnEdit->setEnabled(false);
        return;
    }
    else
    {
        ui->btnDelete->setEnabled(true);
        ui->btnEnable->setEnabled(true);
        ui->btnEdit->setEnabled(true);
    }   
//  if (subscriber->value(currentText + "/enabled").toBool())//enabled
    if (settings->value("rules/" + currentText + "/enabled").toBool())//enabled
        ui->btnEnable->setText("Disable");
    else//disabled
        ui->btnEnable->setText("Enable");
}

void MainWindow::on_btnEnable_clicked()
{

    QString curr = ui->listWidgetRules->currentItem()->text();

    if ( ui->btnEnable->text() == "Enable")
    {
//      publisher->setValue("rules/" + curr + "/enabled",true);
        settings->setValue("rules/" + curr + "/enabled",true);
        ui->listWidgetRules->currentItem()->setForeground(Qt::green);
        ui->btnEnable->setText("Disable");
    }
    else
    {
        settings->setValue("rules/" + curr + "/enabled",false);
//      publisher->setValue("rules/" + curr + "/enabled",false);
        ui->listWidgetRules->currentItem()->setForeground(Qt::red);
        ui->btnEnable->setText("Enable");
    }
}
