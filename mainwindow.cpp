// checksum 0xa193 version 0x30001
/*
  This file was generated by the Mobile Qt Application wizard of Qt Creator.
  MainWindow is a convenience class containing mobile device specific code
  such as screen orientation handling.
  It is recommended not to modify this file, since newer versions of Qt Creator
  may offer an updated version of it.
*/

#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "rule1.h"


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow), subscriber(new QValueSpaceSubscriber("/apps/Maemo/ProfileAutoSwitch"))
    , publisher(new QValueSpacePublisher(QValueSpace::WritableLayer,"/apps/Maemo/ProfileAutoSwitch"))
{
    ui->setupUi(this);
    // Start the GPS
    startGPS();
    //ptr to dialog
    Ruledialog = 0;    
    //fill current rules list,settings from "/apps/Maemo/ProfileAutoSwitch/";

    if (!subscriber->value().isValid()) //need to create /apps/Maemo/ProfileAutoSwitch/
    {
        if (publisher->isConnected())
        {   //set default options
            publisher->setValue("settings/GPS",false);
        }
        else
        {
            //critical error - unable to write to gconf
        }
    }
    subscriber->cd("/apps/Maemo/ProfileAutoSwitch/settings/GPS");
    ui->chkGPS->setChecked(subscriber->value().Bool);

    subscriber->cd("/apps/Maemo/ProfileAutoSwitch/rules");
    if (!subscriber->value().isValid()) //need to create /apps/Maemo/ProfileAutoSwitch/rules
    {
        //set default rule
        publisher->setValue("rules/example rule",false);
    }
    //update rules list if anything changes
    QObject::connect(subscriber, SIGNAL(contentsChanged()), this, SLOT(rulesListChanged()));
    rulesListChanged();//call once now to populate initial rules

}

MainWindow::~MainWindow()
{
    delete ui;
    delete Ruledialog;
    delete subscriber;
    delete publisher;
}

void MainWindow::setOrientation(ScreenOrientation orientation)
{
#if defined(Q_OS_SYMBIAN)
    // If the version of Qt on the device is < 4.7.2, that attribute won't work
    if (orientation != ScreenOrientationAuto) {
        const QStringList v = QString::fromAscii(qVersion()).split(QLatin1Char('.'));
        if (v.count() == 3 && (v.at(0).toInt() << 16 | v.at(1).toInt() << 8 | v.at(2).toInt()) < 0x040702) {
            qWarning("Screen orientation locking only supported with Qt 4.7.2 and above");
            return;
        }
    }
#endif // Q_OS_SYMBIAN

    Qt::WidgetAttribute attribute;
    switch (orientation) {
#if QT_VERSION < 0x040702
    // Qt < 4.7.2 does not yet have the Qt::WA_*Orientation attributes
    case ScreenOrientationLockPortrait:
        attribute = static_cast<Qt::WidgetAttribute>(128);
        break;
    case ScreenOrientationLockLandscape:
        attribute = static_cast<Qt::WidgetAttribute>(129);
        break;
    default:
    case ScreenOrientationAuto:
        attribute = static_cast<Qt::WidgetAttribute>(130);
        break;
#else // QT_VERSION < 0x040702
    case ScreenOrientationLockPortrait:
        attribute = Qt::WA_LockPortraitOrientation;
        break;
    case ScreenOrientationLockLandscape:
        attribute = Qt::WA_LockLandscapeOrientation;
        break;
    default:
    case ScreenOrientationAuto:
        attribute = Qt::WA_AutoOrientation;
        break;
#endif // QT_VERSION < 0x040702
    };
    setAttribute(attribute, true);
}

void MainWindow::showExpanded()
{
#ifdef Q_OS_SYMBIAN
    showFullScreen();
#elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
    showMaximized();
#else
    show();
#endif
}

//void MainWindow::on_pushButton_clicked()
//{
//    locationDataSource->startUpdates();
//}


void MainWindow::rulesListChanged() {
    //clear list
    ui->listWidgetRules->clear();
    //fill list
//    rulesList = new QStringList();
//    rulesList = rules->subPaths();
//    if (rulesList.isEmpty())
//            return;
    foreach(const QString &str, subscriber->subPaths()){
      ui->listWidgetRules->addItem(str);
    }
}

void MainWindow::positionUpdated(QGeoPositionInfo geoPositionInfo)
{
    if (geoPositionInfo.isValid())
    {
        // Stop regular position updates, because a valid position has been
        // obtained
        //locationDataSource->stopUpdates();
        //actually, just slow it
        locationDataSource->setUpdateInterval(30000);//30 sec

        // Get the current location as latitude and longitude
        QGeoCoordinate geoCoordinate = geoPositionInfo.coordinate();
        qreal latitude = geoCoordinate.latitude();
        qreal longitude = geoCoordinate.longitude();
        ui->lblLongitude->setText(QString::number(longitude));
        ui->lblLatitude->setText(QString::number(latitude));
    }
}

void MainWindow::startGPS()
{
    // Obtain the location data source if it is not obtained already
    if (!locationDataSource)
    {
        locationDataSource = QGeoPositionInfoSource::createDefaultSource(this);
        if (locationDataSource)
        {
            // Whenever the location data source signals that the current
            // position is updated, the positionUpdated function is called.
            QObject::connect(locationDataSource,
                             SIGNAL(positionUpdated(QGeoPositionInfo)),
                             this,
                             SLOT(positionUpdated(QGeoPositionInfo)));
            // Start listening for position updates
            locationDataSource->startUpdates();

            locationDataSource->setPreferredPositioningMethods(QGeoPositionInfoSource::NonSatellitePositioningMethods);
        } else {
            // Not able to obtain the location data source
            // TODO: Error handling
        }
    } else {
        // Start listening for position updates
        locationDataSource->startUpdates();
    }
}



void MainWindow::initAreaMonitor()
{
    // Create the area monitor
    QGeoAreaMonitor *monitor =
            QGeoAreaMonitor::createDefaultMonitor(this);

    // Connect the area monitoring signals to the corresponding slots
    connect(monitor, SIGNAL(areaEntered(QGeoPositionInfo)),
            this, SLOT(areaEntered(QGeoPositionInfo)));
    connect(monitor, SIGNAL(areaExited(QGeoPositionInfo)),
            this, SLOT(areaExited(QGeoPositionInfo)));

    QGeoCoordinate location(66.49154, 25.772982);
    monitor->setCenter(location);
    monitor->setRadius(100);
}

void MainWindow::areaEntered(const QGeoPositionInfo &update) {
    // The area has been entered
}

void MainWindow::areaExited(const QGeoPositionInfo &update) {
    // The area has been exited
}

void MainWindow::startSatelliteMonitor()
{
    satelliteInfoSource =
        QGeoSatelliteInfoSource::createDefaultSource(this);
    // Whenever the satellite info source signals that the number of
    // satellites in use is updated, the satellitesInUseUpdated function
    // is called
    QObject::connect(satelliteInfoSource,
                     SIGNAL(satellitesInUseUpdated(
                             const QList<QGeoSatelliteInfo>&)),
                     this,
                     SLOT(satellitesInUseUpdated(
                             const QList<QGeoSatelliteInfo>&)));

    // Whenever the satellite info source signals that the number of
    // satellites in view is updated, the satellitesInViewUpdated function
    // is called
    QObject::connect(satelliteInfoSource,
                     SIGNAL(satellitesInViewUpdated(
                             const QList<QGeoSatelliteInfo>&)),
                     this,
                     SLOT(satellitesInViewUpdated(
                             const QList<QGeoSatelliteInfo>&)));

    // Start listening for satellite updates
    satelliteInfoSource->startUpdates();
}

void MainWindow::satellitesInUseUpdated(
        const QList<QGeoSatelliteInfo> &satellites) {
    // The number of satellites in use is updated
    QMessageBox msgBox;
    msgBox.setText("The number of satellites in use is updated: " +
                   QString::number(satellites.count()));
    msgBox.exec();
}

void MainWindow::satellitesInViewUpdated(
        const QList<QGeoSatelliteInfo> &satellites) {
    // The number of satellites in view is updated
    QMessageBox msgBox;
    msgBox.setText("The number of satellites in view is updated: " +
                   QString::number(satellites.count()));
    msgBox.exec();
}


void MainWindow::on_btnNewRule_clicked()
{
    qint8 intRuleToEdit = rulesList.count() + 1;
    if (Ruledialog == 0)
    {
        Ruledialog =  new Rule1(topLevelWidget(),"Rule " +  QString::number(intRuleToEdit),locationDataSource);
    }
    #ifdef Q_OS_SYMBIAN
         Ruledialog->showFullScreen();//modeless to keep GPS running
    #elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
         Ruledialog->showMaximized();//modeless to keep GPS running
    #else
         Ruledialog->show();//modeless to keep GPS running
    #endif
}

void MainWindow::on_chkGPS_clicked()
{
    if (publisher->isConnected())
    {
        publisher->setValue("settings/GPS",ui->chkGPS->isChecked());
        //todo: restart gps

    }
    else
    {
        //error
    }

}

void MainWindow::on_btnEdit_clicked()
{
    if (!ui->listWidgetRules->currentItem()) return;//no item selected; could show messagebox
    if (Ruledialog == 0)
    {
        Ruledialog =  new Rule1(window(), ui->listWidgetRules->currentItem()->text(),locationDataSource);
    }
    #ifdef Q_OS_SYMBIAN
         Ruledialog->showFullScreen();//modeless to keep GPS running
    #elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
         Ruledialog->showMaximized();//modeless to keep GPS running
    #else
         Ruledialog->show();//modeless to keep GPS running
    #endif
}

void MainWindow::on_btnDelete_clicked()
{
    if (!ui->listWidgetRules->currentItem()) return;//no item selected; could show messagebox
    //show warning messagebox now
    publisher->resetValue("rules/" + ui->listWidgetRules->currentItem()->text());
}

void MainWindow::on_listWidgetRules_currentTextChanged(const QString &currentText)
{
    if (currentText.isNull())//nothing selected
    {
        ui->btnDelete->setEnabled(false);
        ui->btnEnable->setEnabled(false);
        ui->btnEdit->setEnabled(false);
        return;
    }
    else
    {
        ui->btnDelete->setEnabled(true);
        ui->btnEnable->setEnabled(true);
        ui->btnEdit->setEnabled(true);
    }
    subscriber->cd("/apps/Maemo/ProfileAutoSwitch/rules/" + currentText);
    if (subscriber->value().Bool)//enabled
        ui->btnEnable->setText("Disable");
    else//disabled
        ui->btnEnable->setText("Enable");
    //reconnect this thing now
    subscriber->cd("/apps/Maemo/ProfileAutoSwitch/rules");
    QObject::connect(subscriber, SIGNAL(contentsChanged()), this, SLOT(rulesListChanged()));
}

void MainWindow::on_btnEnable_clicked()
{

    if ( ui->btnEnable->text() == "Enable")
    {
        publisher->setValue("rules/" + ui->listWidgetRules->currentItem()->text(),true);
        ui->btnEnable->setText("Disable");
    }
    else
    {
        publisher->setValue("rules/" + ui->listWidgetRules->currentItem()->text(),false);
        ui->btnEnable->setText("Enable");
    }

}
